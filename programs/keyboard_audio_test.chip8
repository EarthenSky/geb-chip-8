// 0x200:
// allocation of static variables
0x6000 // V0 = 0x00
0x6100 // V1 = 0x00
0x6200 // V2 = 0x00
0x6300 // V3 = 0x00
0x6400 // V4 = 0x00
0xa700 // I  = 0x700
0xf455 // [I ..., I+4] = { V0, ..., V4 }

// allocation of dynamic variables
0x6501 // V5 = ypos = 0x01
// 0x210 (start):
0x6600 // V6 = any_key_up = 0x00

0x6101 // V1 = 0x01
0x6401 // V4 = xpos = 0x01
0x2232 // toggle_sprite_if_key_changed()

0x6102 // V1 = 0x02
0x6406 // V4 = xpos = 0x06
0x2232 // toggle_sprite_if_key_changed()

0x6103 // V1 = 0x03
0x640b // V4 = xpos = 0x0b
0x2232 // toggle_sprite_if_key_changed()

0x6104 // V1 = 0x04
0x6410 // V4 = xpos = 0x10
0x2232 // toggle_sprite_if_key_changed()

// 5 * 16ms of latency after ending press
0x6001 // V0 = 0x01
0x3600 // skip next if V6 == 0x00
0xf018 // ST = V0

// some programs loop forever and never end
0x1210 // goto start

// 0x232:
// if key state differs from memory, draw sprite, then update the stored key
// int toggle_sprite_if_key_changed(V1 = key, V4 = xpos, V5 = ypos, V6 = num_keys_down)
// mutable (V0, V2, V6, I, memory)
0xa700 // I = 0x700
0xf11e // I += V1
0xf065 // V0 = memory[I]
0x6200 // V2 = key_state = 0
0xe1a1 // skip next if key[V1] is up
0x6201 // V2 = 1
0x3200 // skip next if V2 == 0
0x7601 // V6 += 1
0x5020 // skip next if V0 == V2
0x1248 // goto print
0x00ee // ret
// 0x248 (print):
0xf129 // I = letter_sprite[V1]
0xd455 // draw_sprite(V4, V5, 5)
0xa700 // I = 0x700
0xf11e // I += V1
0x8020 // V0 = V2
0xf055 // memory[I] = V0
0x00ee // ret
